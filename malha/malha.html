<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulação de Tecido (Massa-Mola)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            color: #eee;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        canvas {
            display: block;
        }
        .instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 8px;
        }
        b { color: #00d2ff; }
    </style>
</head>
<body>

<div class="instructions">
    <h3>Simulação de Tecido</h3>
    <p>Passe o mouse devagar para criar <b>vento</b>.</p>
    <p>Clique e arraste rápido para <b>rasgar</b> a malha.</p>
</div>

<canvas id="canvas"></canvas>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // Configurações da simulação
    const clothWidth = 60;   // Quantidade de pontos na horizontal
    const clothHeight = 40;  // Quantidade de pontos na vertical
    const spacing = 10;      // Espaço entre os pontos
    const gravity = 0.2;     // Força da gravidade
    const friction = 0.99;   // Resistência do ar
    const tearDistance = 50; // Distância limite para rasgar

    let mouse = { x: 0, y: 0, px: 0, py: 0, down: false };

    // Redimensionar canvas
    window.onresize = () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    };
    window.onresize();

    class Point {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.px = x; // Posição anterior X
            this.py = y; // Posição anterior Y
            this.vx = 0;
            this.vy = 0;
            this.pinX = null;
            this.pinY = null;
        }

        update() {
            if (this.pinX !== null && this.pinY !== null) return;

            // Vento do mouse
            let dx = this.x - mouse.x;
            let dy = this.y - mouse.y;
            let dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 80) {
                this.px -= (mouse.x - mouse.px) * 0.8;
                this.py -= (mouse.y - mouse.py) * 0.8;
            }

            // Integração de Verlet
            this.vx = (this.x - this.px) * friction;
            this.vy = (this.y - this.py) * friction;

            this.px = this.x;
            this.py = this.y;

            this.x += this.vx;
            this.y += this.vy + gravity;
        }

        draw() {
            // Desenha apenas os pontos se quiser, mas vamos focar nos links
        }

        pin(x, y) {
            this.pinX = x;
            this.pinY = y;
        }
    }

    class Link {
        constructor(p1, p2) {
            this.p1 = p1;
            this.p2 = p2;
            this.distance = spacing;
            this.isTorn = false;
        }

        update() {
            if (this.isTorn) return;

            let dx = this.p2.x - this.p1.x;
            let dy = this.p2.y - this.p1.y;
            let dist = Math.sqrt(dx * dx + dy * dy);

            // Verifica se deve rasgar
            if (dist > tearDistance) {
                this.isTorn = true;
                return;
            }

            let diff = (this.distance - dist) / dist;
            let offsetX = dx * diff * 0.5;
            let offsetY = dy * diff * 0.5;

            if (this.p1.pinX === null) {
                this.p1.x -= offsetX;
                this.p1.y -= offsetY;
            }
            if (this.p2.pinX === null) {
                this.p2.x += offsetX;
                this.p2.y += offsetY;
            }
        }

        draw() {
            if (this.isTorn) return;
            ctx.beginPath();
            ctx.moveTo(this.p1.x, this.p1.y);
            ctx.lineTo(this.p2.x, this.p2.y);
            ctx.strokeStyle = '#00d2ff88';
            ctx.stroke();
        }
    }

    let points = [];
    let links = [];

    // Criar pontos e links
    const startX = canvas.width / 2 - (clothWidth * spacing) / 2;
    for (let y = 0; y <= clothHeight; y++) {
        for (let x = 0; x <= clothWidth; x++) {
            let p = new Point(startX + x * spacing, 50 + y * spacing);
            
            // Fixar a linha superior
            if (y === 0) p.pin(p.x, p.y);

            // Link horizontal
            if (x > 0) links.push(new Link(points[points.length - 1], p));
            // Link vertical
            if (y > 0) links.push(new Link(points[(y - 1) * (clothWidth + 1) + x], p));

            points.push(p);
        }
    }

    // Input do Mouse
    canvas.onmousedown = (e) => mouse.down = true;
    canvas.onmouseup = (e) => mouse.down = false;
    canvas.onmousemove = (e) => {
        mouse.px = mouse.x;
        mouse.py = mouse.y;
        mouse.x = e.clientX;
        mouse.y = e.clientY;
    };

    function update() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Múltiplos passos de física para maior estabilidade
        for (let i = 0; i < 5; i++) {
            links.forEach(l => l.update());
        }

        points.forEach(p => {
            p.update();
        });

        links.forEach(l => l.draw());

        requestAnimationFrame(update);
    }

    update();
</script>

</body>
</html>